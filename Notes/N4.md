# Q&A Of Our Framework

1. What file stores cookies/local-storage to avoid logging in each test? 
- `auth/orangeHrm.auth.json`, generated once by calling `refreshStorageState()` from `storageStateUtil.js` via
**global setup**. 
- **Work Flow**: Under `playwright.config.js` file, *chromium* and *firefox* project gets triggered. Then these projects **depend** on *setup* project. *Setup* project matches with `global.setup.js` file, which calls `refreshStorageState()` from `storageStateUtil.js`. Then cookies gets saved on `auth/orangeHrm.auth.json`. 

2. When does a *setup* project run relative to the other projects declared within `playwright.config.js`? 
- Always first; browser projects declare `dependencies:['setup']` and wait for it to finish. 

3. Purpose of `cleanEnv()` in `load.env.js`? 
- Validates and type coerces environment variables. Such as, ensures `BASE_URL` is a URL, `HEADLESS` is boolean. 
Throws early if something is missing or mismatching. 

4. Where is `baseURL` for project specified? 
- Inside the `use` block of `playwright.config.js`, and the value is derived from `env.BASE_URL` which is in `load_env.js`. 

5. In Page-Object model, where should locators be defined? 
- Locators are stored in constructor of Page classes. 

6. What is the difference between `expect(element).toBeVisible()` and `element.waitFor({state:'visible'})`? 
- `expect(element).toBeVisible()` is an assertion(validation)(wait + fail/pass), `element.waitFor({state:'visible'})` only waits. No assertion happens if the state doesn't happen. 

7. How does a test in `dashboard.spec.js` call `dashboard` page elements without creating a `dashboard` class object(`new DashboardPage()`)?
    1. Custom fixture layer
    In our `tests/runner-fixtures.js` file we extend Playwright's default `test` object. 
    ```js
    import { test as base } from '@playwright/test';
    import DashboardPage from '../pages/DashboardPage.js';

    export const test = base.extend({
    // Playwright calls this callback for every test
    dashboardPage: async ({ page }, use) => {
    const dash = new DashboardPage(page);  // we instantiate it once here
    await use(dash);                       // expose it to the test body
        }
        });
    ```
    - `base.extend()` defines a fixture named `dashboardPage`. Playwright automatically injects that fixture whenever test's parameter list asks for it. 
    2. Parameter Injection in the spec
    ```js
    import { test, expect } from '../runner-fixtures.js';

    test('dashboard loads', async ({ dashboardPage }) => {   // â† fixture appears here
    await dashboard.goto();                            // no manual "new" needed
    await dashboard.ensureLoaded();
    });
    ```
    * When playwright sees `({dashboardPage})` in the callback signature it:
        - creates the `page` fixture. 
        - Runs the `dashboardPage` fixture callback above, which instantiates `DashboardPage` with that. 
    
8. Our global setup writes `auth/orangeHrm.auth.json`. What stops a second CI from overwriting the file mid-run? 
- File is produced **before** the suite is started, because the `setup` project finishes first and all other shards(project runs) declare `dependencies:[setup]`. Once the file exists, no worker rewrites it. 

9. Why do we freeze the `env` object in `load_env.js`, and what does this JS feature enforce? 
- `Object.freeze(env)` throws in strict mode, if any test tries to reassign a configuration value, guaranteeing immutability at runtime for environment variables. 

10. In our page object constructor we use role based locators(if possible) over CSS values to locate. Why? 
- Roles and accessible names **rarely** change when designer tweak CSS, so role selectors survive style refactors, also improves accessibility. 

11. If a selector(locator) change and breaks multiple tests, which file should we update? 
- We have to find the locator causing the issue, then we should change it in the relevant `Page` file. 

12. What is the purpose of `use:{storageState: undefined}` override inside the `setup` project? 
- It prevents Playwright from trying to load a storage file that hasn't been created yet. Avoids `ENOENT` errors 
during the login once phase. 

13. What is a Circular Import? 
```css
A.js    --- imports -> B.js
       <--- imports -
```
Both modules(files) run their top level code while the other is still initialising. Any variable that hasn't 
finished evaluating is in the temporal dead zone; trying to access it throws 
`ReferenceError: Cannot access 'x' before initialization`. 
* Easy way to identify this issue: 
    - 'undefined is not a function' errors during start up. 
    - Code works when you `console.log()` inside functions. (because functions run later) but crashes at file load time. 


/Users/buseaksit/Downloads/linuxPractice.pem